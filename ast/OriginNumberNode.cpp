//
// Created by laugh on 2021/3/15.
//

#include "OriginNumberNode.h"

void OriginNumberNode::genCode(IoUtil &ioUtil) {
    ioUtil.appendContent(
            "class Number : public Object {\n"
            "private:\n"
            "    int _integer = 0;\n"
            "    double _number = 0;\n"
            "    bool _isInteger = true;\n"
            "    bool _isInt() {\n"
            "        return _isInteger;\n"
            "    }\n"
            "public:\n"
            "    explicit Number(int n) {\n"
            "        _integer = n;\n"
            "    }\n"
            "\n"
            "    explicit Number(double n) {\n"
            "        _number = n;\n"
            "        _isInteger = false;\n"
            "    }\n"
            "\n"
            "    static Number *newObj(double n) {\n"
            "        return new Number(n);\n"
            "    }\n"
            "\n"
            "    static Number *newObj(int n) {\n"
            "        return new Number(n);\n"
            "    }\n"
            "\n"
            "    Object *plus(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return Number::newObj(_integer + num->_integer);\n"
            "        } else if (num->_isInt()) {\n"
            "            return Number::newObj(_number + num->_integer);\n"
            "        } else if (_isInt()) {\n"
            "            return Number::newObj(_integer + num->_number);\n"
            "        } else {\n"
            "            return Number::newObj(_number + num->_number);\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object *minus(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return Number::newObj(_integer - num->_integer);\n"
            "        } else if (num->_isInt()) {\n"
            "            return Number::newObj(_number - num->_integer);\n"
            "        } else if (_isInt()) {\n"
            "            return Number::newObj(_integer - num->_number);\n"
            "        } else {\n"
            "            return Number::newObj(_number - num->_number);\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object *times(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return Number::newObj(_integer * num->_integer);\n"
            "        } else if (num->_isInt()) {\n"
            "            return Number::newObj(_number * num->_integer);\n"
            "        } else if (_isInt()) {\n"
            "            return Number::newObj(_integer * num->_number);\n"
            "        } else {\n"
            "            return Number::newObj(_number * num->_number);\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object *divide(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            if (_integer % num->_integer == 0) {\n"
            "                return Number::newObj(_integer / num->_integer);\n"
            "            } else {\n"
            "                return Number::newObj((double) _integer / num->_integer);\n"
            "            }\n"
            "        } else if (num->_isInt()) {\n"
            "            return Number::newObj(_number / num->_integer);\n"
            "        } else if (_isInt()) {\n"
            "            return Number::newObj(_integer / num->_number);\n"
            "        } else {\n"
            "            return Number::newObj(_number / num->_number);\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object *mod(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        return Number::newObj(_integer % num->_integer);\n"
            "    }\n"
            "\n"
            "    Object * lessThan(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return _integer < num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (num->_isInt()) {\n"
            "            return _number < num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (_isInt()) {\n"
            "            return _integer < num->_number ? True::newObj() : nullptr;\n"
            "        } else {\n"
            "            return _number < num->_number ? True::newObj() : nullptr;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object * lessEqualThan(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return _integer <= num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (num->_isInt()) {\n"
            "            return _number <= num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (_isInt()) {\n"
            "            return _integer <= num->_number ? True::newObj() : nullptr;\n"
            "        } else {\n"
            "            return _number <= num->_number ? True::newObj() : nullptr;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object * moreThan(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return _integer > num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (num->_isInt()) {\n"
            "            return _number > num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (_isInt()) {\n"
            "            return _integer > num->_number ? True::newObj() : nullptr;\n"
            "        } else {\n"
            "            return _number > num->_number ? True::newObj() : nullptr;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object * moreEqualThan(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return _integer >= num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (num->_isInt()) {\n"
            "            return _number >= num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (_isInt()) {\n"
            "            return _integer >= num->_number ? True::newObj() : nullptr;\n"
            "        } else {\n"
            "            return _number >= num->_number ? True::newObj() : nullptr;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object * equal(Object *obj) override {\n"
            "        auto num = dynamic_cast<Number *>(obj);\n"
            "        if (num == nullptr) {\n"
            "            return nullptr;\n"
            "        }\n"
            "        if (num->_isInt() && _isInt()) {\n"
            "            return _integer == num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (num->_isInt()) {\n"
            "            return _number == num->_integer ? True::newObj() : nullptr;\n"
            "        } else if (_isInt()) {\n"
            "            return _integer == num->_number ? True::newObj() : nullptr;\n"
            "        } else {\n"
            "            return _number == num->_number ? True::newObj() : nullptr;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    Object * toString() override {\n"
            "        if (_isInt()) {\n"
            "            return String::newObj(std::to_string(_integer));\n"
            "        }\n"
            "        return String::newObj(std::to_string(_number));\n"
            "    }\n"
            "};"
    );
    ioUtil.newLine();
}

std::string OriginNumberNode::toString() const {
    return "Number";
}


